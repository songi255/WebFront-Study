//프로그래밍 : 요구사항집합을 분석하여, 적절한 자료구조와 함수집합으로 변환 후, 그 흐름을 제어하는 것.

/*
    표현식(expression) : 값으로 평가될 수 있는 문. (10 + 20, power(2,2) 등)
        - 값 : 표현식이 평가되어 생성된 결과
    크롬 콘솔에 비표현식 치면 항상 undefined가 나옴. (완료값. complete value)
*/

//선언 declaration VS 정의 definition : 선언은 컴파일러에게 알리는것. 정의는 실제로 할당하는 것

//변수의 선언
x; // 암묵적 전역변수.
var x; //함수레벨 스코프. 이렇게 선언하면 전역객체의 프로퍼티가 됨. 선언시 쓰레기값 방지를 위해 undefined로 초기화된다. 즉 대입이 2번 되는 것.
// 이때, 기존 있던 undefined 에 덧씌워지는것이 아니라, 새로운 메모리주소에 재할당된다.
// 이후 새 값으로 재할당할 때 마다 똑같이, 새로운 메모리 주소에 재할당한다. 성능은 안좋을듯.
//if 나 for은 함수가 아니므로 전역취급이 된다. 그래서 전역변수가 남발된다.
var x; // 심지어 재선언도 가능하다. 이게 의도치않은 재선언으로 부작용이 생길 수 있다.
// 사실 재선언은 아니고, 2가지 case로 나뉜다.
var x; // 재선언인데 초기화하지 않을경우 : 무시된다.(에러 없음)
var x = 10; // 재선언인데 초기화하는 경우 : var이 없는것처럼 x = 10으로 바꾸어 실행한다.(에러없음)
// 초기에는 왜 이렇게 호이스팅 등등 사용했나? -> 처음 JS가 나왔을때는 정말 간단한 코드용이었고, 개발자들이 제발 사용해주길 바랬기때문에
// 최대한 오류를 줄이는 방향으로 설계되었다. 이게 현재로 오니 많은 부작용으로 나타나고있다.

//ES6 블록레벨 스코프
let y; // 전역객체가 되지 않음(보이지않는 개념적인 블록내에 존재). 즉 window.y로 접근불가. 호이스팅 되지 않음 (되는것처럼 보인다. 하지만 선언은 되나, 초기화가 되지 않아 참조에러가 발생한다.)
//const도 마찬가지로 호이스팅 되지 않는것처럼 동작한다.
const z = 3; // 상수. 선언과 동시에 반드시 초기화. const로 재정의는 되버리네...
// 이처럼 선언은 되었고, undefined로 초기화는 되지 않는 사이시간을 TDZ (일시적 사각시대)라고 한다.
// 95% 이상이 const를 쓴다고 한다. 기본적으로 const 로 선언하고, 변경이 필요한 경우에 한해 let을 사용한다.

//TDZ
console.log(letVar); // 오류. 선언은 됬으나, 초기화는 되지 않았다. TDZ안에 있다. 즉, 참조오류를 발생시킨다. var은 여기서도 오류없이 undefined가 찍힌다는 것이다.
let letVar; // 선언은 초기에 됬고, 여기서 undefined로 초기화가 발생한다.
console.log(letVar); // 초기화가 됬으므로 undefined 반환
letVar = 8;
console.log(letVar); // 8 반환.

// 변수 호이스팅 variable hoisting
// 런타임 이전에 선언문을 모두 실행
console.log(hoist); //변수선언을 늦게했으나, 엔진이 실행전 평가함.
var hoist = 3; //var hoist; 와 hoist = 3으로 나누어 실행.
// hoist = 3; 은 평가 이후 순차실행. 고로 undefined 가 찍힌다.

//재할당 : 새로운 메모리 공간에 생성. 값이 대체되는것이 아님.
hoist = 4;

//managed language vs unmanaged language : 메모리 할당 직접 하는지여부.

//변수 네이밍 - 특수문자 불가. $_가능. 숫자시작 불가. 대소문자 구분

//;은 붙이는걸 권장. 예기치못한 동작할 수 있으므로.. 안붙여도 자동으로 붙여줌.
//if, for 뒤엔 ;쓰지 않는다. 자체가 종결의 의미를 가지므로..

// Naming Convention
//  - camelCase : 대부분 이거 사용
//  - snake_case
//  - PascalCase : 클래스 등에 이거 사용
//  - typeHungarianCase
























